import resources/tests/core/tuples.clc

data List a = Cons a (List a) | Empty;

let head = \l -> case l of
    (Cons x _) -> x;

let tail = \l -> case l of
    Empty -> Empty
    (Cons _ xs) -> xs;

let doubleAll = \l -> case l of
    (Cons x xs) -> (Cons (intMul 2 x) (doubleAll xs))
    _ -> Empty;


let wagh = \n -> \l -> case l of
        Empty -> Empty;
        (Cons x xs) -> (Cons x xs)

let zipAdd = \xl -> \yl -> case xl of
    Empty -> Empty
    (Cons x xs) -> case yl of
        Empty -> Empty;
        (Cons y ys) -> (Cons (intAdd x y) (zipAdd xs ys))


let take = \n -> \l -> case n of
    0 -> Empty;
    _ -> case l of
        Empty -> Empty;
        (Cons x xs) -> (Cons x (take (intAdd n (intNeg 1)) xs))

let drop = \n -> \l -> case n of
    0 -> l;
    _ -> case l of 
        Empty -> Empty
        (Cons x xs) -> (drop (intAdd n (intNeg 1)) xs)

let last = \l -> case l of
    (Cons x Empty) -> x;
    (Cons x xs) -> (last xs);

let ount = \l -> case l of
    Empty -> 0;
    (Cons x xs) -> (intAdd 1 (ount xs))

let repeat = \x -> (Cons x (repeat x))

let foldr = \f -> \s -> \l -> case l of
    Empty -> s;
    (Cons x xs) -> (f x (foldr f s xs));

let mrrp = \f -> (f (mrrp f))

# f is (m4 -> m2) (arbitrary to arbitrary)
# (mrrp f) is meta@4 (we recognize it as Something)
# f (mrrp f) is meta@2 
# mrrp is (meta@4 -> meta@2) -> meta@2
# we want it to be `(a -> a) -> a`, issue is that it's not,, self instantiating mrrp?

# let map = \f -> \l -> (foldr (\e -> \xs -> (Cons (f e) xs)) Empty l)

# let sum = \xs -> (foldr intAdd 0 xs)

let iterate = \f -> \x -> (Cons x (iterate f (f x)))

#let naturals = (iterate (intAdd 1) 1)
